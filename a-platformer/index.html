<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Platformer — Builder Only (No Procedural Tiles)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
  <style>
    :root { --ui-bg: rgba(240,240,240,0.95); --dark: #111; --light: #fff; }
    html,body { height:100%; margin:0; background:#aaa; -webkit-user-select:none; user-select:none; }
    canvas { display:block; margin:0 auto; background:#aaa; touch-action:none; }
    #ui { position:fixed; left:0; right:0; top:6px; text-align:center; font-family:monospace; z-index:120; pointer-events:none; color:var(--dark); font-size:16px; }
    .dialog { position:fixed; left:50%; top:8vh; transform:translateX(-50%); width:92%; max-width:520px; background:var(--ui-bg); color:var(--dark); padding:16px 18px; border-radius:10px; box-shadow:0 8px 32px rgba(0,0,0,0.25); z-index:200; font-family:Arial,monospace; pointer-events:auto; }
    .btn { display:inline-block; padding:8px 12px; margin:6px 6px 6px 0; border-radius:8px; border:1px solid #444; background:#efefef; cursor:pointer; }
    .btn.danger { background:#fdd; border-color:#d33; color:#600; }
    textarea { width:100%; height:120px; margin-top:8px; box-sizing:border-box; font-family:monospace; }
    input[type=text] { width:64%; padding:6px; margin-right:8px; font-family:monospace; }
    #touchControls { position:fixed; bottom:16px; left:16px; right:16px; z-index:150; pointer-events:auto; display:flex; justify-content:space-between; align-items:flex-end; }
    .touchBtn { width:76px; height:76px; border-radius:14px; background:rgba(255,255,255,0.92); display:flex; align-items:center; justify-content:center; font-size:20px; border:1px solid #555; box-shadow:0 6px 18px rgba(0,0,0,0.18); -webkit-tap-highlight-color: transparent; user-select:none; }
    .touchBtn.small { width:64px; height:64px; }
    @media (max-width:520px) { .touchBtn { width:64px; height:64px; } .touchBtn.small { width:56px; height:56px; } }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="900" height="600"></canvas>
  <div id="ui">←/→ Move  •  ↑/Space Jump  •  B: Builder  •  I: Invert  •  ESC: Menu</div>

  <!-- Menu -->
  <div id="menu" class="dialog" style="display:none;">
    <h2>Platformer — Menu</h2>
    <div>
      <button id="menuNew" class="btn">New Blank Level</button>
      <button id="menuPlay" class="btn">Play Current Level</button>
      <button id="menuBuilder" class="btn">Open Builder</button>
      <button id="menuSave" class="btn">Autosave</button>
      <button id="menuExport" class="btn">Export (JSON)</button>
      <button id="menuImportOpen" class="btn">Import (Paste JSON)</button>
    </div>

    <hr />

    <div style="text-align:left;">
      <div style="margin-bottom:8px;"><strong>Saved levels (localStorage):</strong></div>
      <div id="savedList"></div>
      <div style="margin-top:8px;">
        <input id="saveName" type="text" placeholder="Save name (e.g. my-level)" />
        <button id="saveAsBtn" class="btn">Save As</button>
      </div>
    </div>

    <hr />

    <div style="text-align:left;">
      <div style="margin-bottom:8px;"><strong>Remote JSON files in this folder (auto-detected):</strong></div>
      <div id="remoteList">Scanning folder for .json files... <span id="remoteStatus"></span></div>
      <div style="margin-top:8px;">
        <button id="remoteRescan" class="btn">Rescan Folder</button>
      </div>
      <div style="margin-top:10px; font-size:13px; color:#444;">
        If your server doesn't expose directory listings, use Import to paste JSON or add explicit links to index.html.
      </div>
    </div>

    <div style="margin-top:12px; text-align:right;">
      <button id="menuClose" class="btn">Close</button>
    </div>
  </div>

  <!-- Export dialog -->
  <div id="exportDialog" class="dialog" style="display:none;">
    <h2>Export Current Level (JSON)</h2>
    <textarea id="exportArea" readonly></textarea>
    <div style="text-align:right; margin-top:8px;">
      <button id="exportCopy" class="btn">Copy</button>
      <button id="exportClose" class="btn">Close</button>
    </div>
  </div>

  <!-- Import dialog -->
  <div id="importDialog" class="dialog" style="display:none;">
    <h2>Import Level (paste JSON)</h2>
    <textarea id="importArea" placeholder="Paste level JSON here"></textarea>
    <div style="margin-top:8px;">
      <input id="importName" type="text" placeholder="Optional: name to save as" />
      <button id="importLoad" class="btn">Import & Play</button>
      <button id="importClose" class="btn">Close</button>
    </div>
    <div id="importMsg" style="color:#b00; margin-top:8px;"></div>
  </div>

  <!-- Touch controls -->
  <div id="touchControls" style="display:none; pointer-events:auto;">
    <div style="display:flex; gap:10px; align-items:center;">
      <div style="display:flex;flex-direction:column;align-items:center;">
        <div id="leftBtn" class="touchBtn">&#8592;</div>
        <div style="font-size:12px; margin-top:6px;">Left</div>
      </div>
      <div style="display:flex;flex-direction:column;align-items:center;">
        <div id="rightBtn" class="touchBtn">&#8594;</div>
        <div style="font-size:12px; margin-top:6px;">Right</div>
      </div>
    </div>
    <div style="display:flex;flex-direction:column;align-items:center;">
      <div id="jumpBtn" class="touchBtn small">&#9650;</div>
      <div style="font-size:12px; margin-top:6px;">Jump</div>
    </div>
  </div>

<script>
/*
  This file: Platformer with Builder, export/import, touch support.
  Key change: NO procedurally generated tiles/chunks except the small starter ground
  (staticPlatforms) created by "New Blank Level" / reset. Everything else must be placed
  via the builder or imported JSON. This ensures no runtime-created tiles appear.
*/

/* ---------- Canvas + resize ---------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const BASE_W = 900, BASE_H = 600;
function resizeCanvas() {
  // keep internal resolution fixed; scale CSS size to fit screen
  const maxW = Math.min(window.innerWidth, 1400);
  const maxH = Math.min(window.innerHeight, 1000);
  let scale = Math.min(maxW / BASE_W, maxH / BASE_H);
  if (scale < 0.5) scale = 0.5;
  canvas.style.width = Math.round(BASE_W * scale) + 'px';
  canvas.style.height = Math.round(BASE_H * scale) + 'px';
  canvas.width = BASE_W; canvas.height = BASE_H;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ---------- Constants & state ---------- */
const TILE = 40;
const PLAYER_SIZE = 36;
const GRAVITY = 0.72;
const JUMP_V = -14;
const MAX_FALL = 26;

let invert = false;
let builderMode = false;
let inMenu = true;

let camX = 0, camY = 0;
const keys = {};
let touchState = { left: false, right: false, jump: false };

/* ---------- Level (no procedural generation) ----------
   - staticPlatforms: only platforms saved/imported/created by builder or New Level.
   - builderTiles: grid toggles saved to localStorage/autosave.
   - NO generated chunks at runtime (by request).
*/
class Level {
  constructor() { this.resetToBlank(); }
  resetToBlank() {
    // clear and create small starter ground only
    this.staticPlatforms = [];
    this.builderTiles = {};
    this.checkpointX = 0;
    // starter ground centered at x=0 (a few tiles)
    for (let i = -6; i <= 6; i++) {
      this.staticPlatforms.push({ x: i * TILE, y: BASE_H - 80, w: TILE, h: TILE });
    }
  }
  // Toggle builder tile at tile coords
  toggleBuilderTile(tx, ty) {
    const k = tx + '_' + ty;
    this.builderTiles[k] = !this.builderTiles[k];
    autosaveCurrentLevel();
  }
  // Return platforms for rendering/collision: static + builder tiles only.
  getPlatforms(viewX, viewY) {
    const out = [];
    for (const p of this.staticPlatforms) out.push(p);
    for (const k in this.builderTiles) {
      if (this.builderTiles[k]) {
        const [tx, ty] = k.split('_').map(Number);
        out.push({ x: tx * TILE, y: ty * TILE, w: TILE, h: TILE, builder: true });
      }
    }
    return out;
  }
  // Export only editable parts
  exportData() {
    return {
      staticPlatforms: JSON.parse(JSON.stringify(this.staticPlatforms)),
      builderTiles: JSON.parse(JSON.stringify(this.builderTiles)),
      checkpointX: this.checkpointX || 0
    };
  }
  // Import / load level data
  importData(d) {
    this.staticPlatforms = d.staticPlatforms || [];
    this.builderTiles = d.builderTiles || {};
    this.checkpointX = d.checkpointX || 0;
  }
  checkCheckpoint(px, py) {
    for (const p of this.staticPlatforms) {
      if (p.checkpoint &&
          px > p.x - PLAYER_SIZE / 2 && px < p.x + p.w + PLAYER_SIZE / 2 &&
          py > p.y - 10 && py < p.y + p.h + 10) {
        this.checkpointX = p.x;
        return true;
      }
    }
    return false;
  }
  getRespawnPos() {
    if (this.checkpointX) return { x: this.checkpointX + 20, y: BASE_H - 200 };
    return { x: 60, y: BASE_H - 200 };
  }
}
let level = new Level();

/* ---------- Player ---------- */
class Player {
  constructor() { this.respawn(); }
  respawn() {
    const pos = level.getRespawnPos();
    this.x = pos.x; this.y = pos.y; this.vx = 0; this.vy = 0; this.dead = false; this.deathTimer = 0;
  }
  update(platforms) {
    if (this.dead) {
      this.deathTimer--; if (this.deathTimer <= 0) this.respawn(); return;
    }
    // movement input
    let move = 0;
    if (keys['ArrowLeft'] || keys['KeyA'] || touchState.left) move = -1;
    if (keys['ArrowRight'] || keys['KeyD'] || touchState.right) move = 1;
    this.vx += move * 1.4;
    if (!move) this.vx *= 0.78;
    if (Math.abs(this.vx) > 9) this.vx = Math.sign(this.vx) * 9;
    // gravity
    this.vy += GRAVITY;
    if (this.vy > MAX_FALL) this.vy = MAX_FALL;
    // collision (simple AABB)
    let onGround = false;
    for (const p of platforms) {
      const nextX = this.x + this.vx;
      const nextY = this.y + this.vy;
      if (nextX + PLAYER_SIZE > p.x && nextX < p.x + p.w && nextY + PLAYER_SIZE > p.y && nextY < p.y + p.h) {
        // landing
        if (this.vy > 0 && this.y + PLAYER_SIZE <= p.y + 6) {
          this.y = p.y - PLAYER_SIZE; this.vy = 0; onGround = true;
          if (p.checkpoint) level.checkpointX = p.x;
        } else if (this.vy < 0 && this.y >= p.y + p.h - 6) {
          this.y = p.y + p.h; this.vy = 0.5;
        } else {
          // push horizontally
          if (this.vx > 0) this.x = p.x - PLAYER_SIZE;
          else if (this.vx < 0) this.x = p.x + p.w;
          this.vx = 0;
        }
      }
    }
    // jump
    if ((keys['ArrowUp'] || keys['Space'] || touchState.jump) && onGround) {
      this.vy = JUMP_V;
    }
    // apply velocities
    this.x += this.vx; this.y += this.vy;
    // death off bottom
    if (this.y > BASE_H + 240) { this.dead = true; this.deathTimer = 48; }
  }
}
let player = new Player();

/* ---------- Input (keyboard + touch) ---------- */
window.addEventListener('keydown', (e) => {
  if (!inMenu) {
    if (e.code === 'KeyI') invert = !invert;
    if (e.code === 'KeyB') { builderMode = !builderMode; showTransient(builderMode ? 'Builder ON' : 'Builder OFF'); }
    if (e.code === 'Escape') showMenu();
  }
  keys[e.code] = true;
});
window.addEventListener('keyup', (e) => keys[e.code] = false);

// Touch buttons mapping
function setTouch(which, val) { touchState[which] = val; }
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const jumpBtn = document.getElementById('jumpBtn');
function bindTouch(el, onDown, onUp) {
  el.addEventListener('mousedown', (ev) => { ev.preventDefault(); onDown(); });
  document.addEventListener('mouseup', () => onUp());
  el.addEventListener('touchstart', (ev) => { ev.preventDefault(); onDown(); }, {passive:false});
  el.addEventListener('touchend', (ev) => { ev.preventDefault(); onUp(); }, {passive:false});
  el.addEventListener('touchcancel', (ev) => { ev.preventDefault(); onUp(); }, {passive:false});
}
bindTouch(leftBtn, () => setTouch('left', true), () => setTouch('left', false));
bindTouch(rightBtn, () => setTouch('right', true), () => setTouch('right', false));
bindTouch(jumpBtn, () => setTouch('jump', true), () => setTouch('jump', false));

/* ---------- Builder click/touch handling ---------- */
canvas.addEventListener('mousedown', (e) => {
  if (!builderMode || inMenu) return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  const worldX = mx + camX;
  const worldY = my + camY;
  const tx = Math.floor(worldX / TILE), ty = Math.floor(worldY / TILE);
  level.toggleBuilderTile(tx, ty);
});
canvas.addEventListener('touchstart', (e) => {
  if (!builderMode || inMenu) return;
  const t = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const mx = (t.clientX - rect.left) * (canvas.width / rect.width);
  const my = (t.clientY - rect.top) * (canvas.height / rect.height);
  const worldX = mx + camX;
  const worldY = my + camY;
  const tx = Math.floor(worldX / TILE), ty = Math.floor(worldY / TILE);
  level.toggleBuilderTile(tx, ty);
}, {passive:false});

// track mouse world for hover display in builder
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  window._mouseWorld = { mx: mx + camX, my: my + camY };
});

/* ---------- Camera + main loop ---------- */
function updateCamera() {
  const targetX = player.x - BASE_W / 2 + PLAYER_SIZE / 2;
  const targetY = player.y - BASE_H / 2 + PLAYER_SIZE / 2;
  camX += (targetX - camX) * 0.12;
  camY += (targetY - camY) * 0.12;
}

function draw() {
  // background
  ctx.fillStyle = invert ? '#eee' : '#888';
  ctx.fillRect(0, 0, BASE_W, BASE_H);

  // get platforms (static + builder only)
  const platforms = level.getPlatforms(camX, camY);

  // world draw
  ctx.save();
  ctx.translate(-camX, -camY);

  // draw platforms
  for (const p of platforms) {
    if (p.builder) ctx.fillStyle = invert ? '#ddd' : '#333';
    else ctx.fillStyle = p.checkpoint ? (invert ? '#ff8' : '#fc0') : (invert ? '#fff' : '#000');
    ctx.fillRect(p.x, p.y, p.w, p.h);
    if (p.checkpoint) {
      ctx.strokeStyle = invert ? '#333' : '#fff';
      ctx.lineWidth = 3;
      ctx.strokeRect(p.x + 6, p.y + 6, p.w - 12, p.h - 12);
    }
  }

  // builder hover
  if (builderMode && window._mouseWorld) {
    const { mx, my } = window._mouseWorld;
    ctx.strokeStyle = invert ? '#666' : '#fff';
    ctx.lineWidth = 2;
    ctx.strokeRect(Math.floor(mx / TILE) * TILE, Math.floor(my / TILE) * TILE, TILE, TILE);
  }

  // player
  ctx.fillStyle = invert ? '#000' : '#fff';
  ctx.fillRect(player.x, player.y, PLAYER_SIZE, PLAYER_SIZE);
  ctx.strokeStyle = invert ? '#fff' : '#000';
  ctx.lineWidth = 2;
  ctx.strokeRect(player.x, player.y, PLAYER_SIZE, PLAYER_SIZE);

  ctx.restore();

  // UI text
  document.getElementById('ui').textContent = builderMode ? 'BUILDER MODE • Tap/click to toggle tile • B: Exit • ESC: Menu' : '←/→ Move • ↑/SPACE Jump • B: Builder • I: Invert • ESC: Menu';

  // death overlay
  if (player.dead) {
    ctx.fillStyle = invert ? 'rgba(255,255,255,0.85)' : 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, BASE_W, BASE_H);
    ctx.font = 'bold 40px Arial'; ctx.fillStyle = invert ? '#333' : '#fff'; ctx.textAlign = 'center';
    ctx.fillText('You Died!', BASE_W / 2, BASE_H / 2 - 10);
    ctx.font = '20px Arial'; ctx.fillText('Respawning...', BASE_W / 2, BASE_H / 2 + 28);
  }
}

function step() {
  if (inMenu) { ctx.clearRect(0,0,BASE_W,BASE_H); requestAnimationFrame(step); return; }
  // update physics with current platforms
  const platforms = level.getPlatforms(camX, camY);
  player.update(platforms);
  updateCamera();
  draw();
  requestAnimationFrame(step);
}
requestAnimationFrame(step);

/* ---------- Autosave / localStorage / import-export ---------- */
const LS_PREFIX = 'pf_level_'; // prefix for saved named levels
function autosaveCurrentLevel() {
  try {
    const data = level.exportData();
    localStorage.setItem(LS_PREFIX + 'autosave', JSON.stringify(data));
  } catch (err) { console.warn('Autosave failed', err); }
}
function saveLevelAs(name) {
  try {
    const data = level.exportData();
    localStorage.setItem(LS_PREFIX + name, JSON.stringify(data));
    refreshSavedList();
    showTransient('Saved as "' + name + '"');
  } catch (err) { showTransient('Save failed: ' + err); }
}
function loadSavedLevel(name) {
  try {
    const raw = localStorage.getItem(LS_PREFIX + name);
    if (!raw) { showTransient('No saved level by that name'); return; }
    const obj = JSON.parse(raw);
    level.importData(obj);
    player.respawn();
    camX = camY = 0;
    showTransient('Loaded "' + name + '"');
  } catch (err) { showTransient('Load failed: ' + err); }
}
function deleteSavedLevel(name) {
  localStorage.removeItem(LS_PREFIX + name);
  refreshSavedList();
  showTransient('Deleted "' + name + '"');
}
function refreshSavedList() {
  const listEl = document.getElementById('savedList'); listEl.innerHTML = '';
  const keysArr = Object.keys(localStorage).filter(k => k.startsWith(LS_PREFIX) && k !== LS_PREFIX + 'autosave');
  if (keysArr.length === 0) { listEl.innerHTML = '<div style="color:#444; font-style:italic">No saved levels</div>'; return; }
  for (const k of keysArr) {
    const name = k.substring(LS_PREFIX.length);
    const row = document.createElement('div'); row.style.marginBottom = '8px';
    row.innerHTML = `<strong>${name}</strong> `;
    const loadBtn = document.createElement('button'); loadBtn.className='btn'; loadBtn.textContent='Load';
    loadBtn.onclick = () => { loadSavedLevel(name); inMenu = false; hideMenu(); };
    const playBtn = document.createElement('button'); playBtn.className='btn'; playBtn.textContent='Play';
    playBtn.onclick = () => { loadSavedLevel(name); inMenu = false; hideMenu(); };
    const delBtn = document.createElement('button'); delBtn.className='btn danger'; delBtn.textContent='Delete';
    delBtn.onclick = () => { if (confirm('Delete "' + name + '"?')) deleteSavedLevel(name); };
    row.appendChild(loadBtn); row.appendChild(playBtn); row.appendChild(delBtn);
    listEl.appendChild(row);
  }
}

/* Export */
const exportDialog = document.getElementById('exportDialog');
function openExportDialog() {
  document.getElementById('exportArea').value = JSON.stringify(level.exportData(), null, 2);
  exportDialog.style.display = 'block';
}
document.getElementById('exportCopy').addEventListener('click', () => {
  const text = document.getElementById('exportArea').value;
  navigator.clipboard?.writeText(text).then(() => showTransient('Copied to clipboard'));
});
document.getElementById('exportClose').addEventListener('click', () => exportDialog.style.display = 'none');

/* Import */
const importDialog = document.getElementById('importDialog');
function openImportDialog() {
  document.getElementById('importArea').value = '';
  document.getElementById('importName').value = '';
  document.getElementById('importMsg').textContent = '';
  importDialog.style.display = 'block';
}
document.getElementById('importLoad').addEventListener('click', () => {
  const txt = document.getElementById('importArea').value.trim();
  if (!txt) { document.getElementById('importMsg').textContent = 'Paste JSON first'; return; }
  try {
    const data = JSON.parse(txt);
    level.importData(data);
    player.respawn(); camX = camY = 0;
    const name = document.getElementById('importName').value.trim();
    if (name) saveLevelAs(name);
    importDialog.style.display = 'none';
    showTransient('Imported level' + (name ? ' and saved as "' + name + '"' : ''));
  } catch (err) {
    document.getElementById('importMsg').textContent = 'Invalid JSON: ' + err;
  }
});
document.getElementById('importClose').addEventListener('click', () => importDialog.style.display = 'none');

/* ---------- Menu interactions & remote folder scan ---------- */
function showMenu(msg) {
  inMenu = true; document.getElementById('menu').style.display = 'block';
  if (msg) showTransient(msg);
  refreshSavedList();
  scanFolderForJSON();
  updateTouchControlsVisibility();
}
function hideMenu() { inMenu = false; document.getElementById('menu').style.display = 'none'; updateTouchControlsVisibility(); }
document.getElementById('menuClose').addEventListener('click', hideMenu);

/* Menu buttons */
document.getElementById('menuNew').addEventListener('click', () => {
  if (!confirm('Create a blank new level? Unsaved edits will be lost.')) return;
  level.resetToBlank(); player.respawn(); camX = camY = 0; showTransient('New blank level');
});
document.getElementById('menuPlay').addEventListener('click', () => hideMenu());
document.getElementById('menuBuilder').addEventListener('click', () => { builderMode = true; hideMenu(); });
document.getElementById('menuSave').addEventListener('click', () => { autosaveCurrentLevel(); showTransient('Autosaved'); });
document.getElementById('menuExport').addEventListener('click', openExportDialog);
document.getElementById('menuImportOpen').addEventListener('click', openImportDialog);
document.getElementById('saveAsBtn').addEventListener('click', () => {
  const name = document.getElementById('saveName').value.trim();
  if (!name) { showTransient('Enter a name to save'); return; }
  saveLevelAs(name);
});

/* Remote folder scan for JSON files (best-effort) */
async function scanFolderForJSON() {
  const remoteList = document.getElementById('remoteList'), status = document.getElementById('remoteStatus');
  remoteList.innerHTML = 'Scanning folder for .json files...'; status.textContent = '';
  try {
    const href = window.location.href;
    const parts = href.split('/'); parts.pop(); const dirUrl = parts.join('/') + '/';
    const resp = await fetch(dirUrl, { method: 'GET' });
    const text = await resp.text();
    const jsonUrls = [];
    const hrefRegex = /href\s*=\s*["']([^"']+\.json)["']/ig;
    let m;
    while ((m = hrefRegex.exec(text)) !== null) jsonUrls.push(m[1]);
    const plainRegex = /(?:["'\(])([^"'\(\)]+\.json)(?:["'\)])/ig;
    while ((m = plainRegex.exec(text)) !== null) if (!jsonUrls.includes(m[1])) jsonUrls.push(m[1]);
    const normalized = jsonUrls.map(u => {
      if (u.startsWith('http://') || u.startsWith('https://')) return u;
      if (u.startsWith('/')) return window.location.origin + u;
      return dirUrl + u;
    });
    const uniq = [...new Set(normalized)];
    if (uniq.length === 0) { remoteList.innerHTML = 'No .json links found in directory listing.'; status.textContent = '(If server hides listings, use Import)'; return; }
    remoteList.innerHTML = '';
    for (const url of uniq) {
      const name = url.split('/').pop();
      const row = document.createElement('div'); row.style.marginBottom = '8px';
      row.innerHTML = `<strong>${name}</strong> `;
      const loadBtn = document.createElement('button'); loadBtn.className='btn'; loadBtn.textContent='Load';
      loadBtn.onclick = async () => {
        try { const r = await fetch(url); const d = await r.json(); level.importData(d); player.respawn(); hideMenu(); showTransient('Loaded ' + name); }
        catch (err) { showTransient('Failed to load: ' + err); }
      };
      const saveBtn = document.createElement('button'); saveBtn.className='btn'; saveBtn.textContent='Save Locally';
      saveBtn.onclick = async () => {
        try { const r = await fetch(url); const d = await r.json(); const suggested = name.replace(/\.json$/i,''); localStorage.setItem(LS_PREFIX + suggested, JSON.stringify(d)); refreshSavedList(); showTransient('Saved remote as "' + suggested + '"'); }
        catch (err) { showTransient('Failed to fetch remote: ' + err); }
      };
      row.appendChild(loadBtn); row.appendChild(saveBtn); remoteList.appendChild(row);
    }
  } catch (err) {
    document.getElementById('remoteList').innerHTML = 'Could not scan folder for .json files: ' + err;
    status.textContent = '(You can still import manually)';
  }
}
document.getElementById('remoteRescan').addEventListener('click', scanFolderForJSON);

/* ---------- Touch controls visibility ---------- */
function isTouchDevice() { return (('ontouchstart' in window) || navigator.maxTouchPoints > 0); }
function updateTouchControlsVisibility() {
  const tc = document.getElementById('touchControls');
  tc.style.display = (isTouchDevice() && !inMenu) ? 'flex' : 'none';
}

/* ---------- Small UI helpers ---------- */
let _msgTimer = 0;
function showTransient(t) { document.getElementById('ui').textContent = t; _msgTimer = 240; }
setInterval(() => {
  if (_msgTimer > 0) { _msgTimer--; if (_msgTimer === 0) document.getElementById('ui').textContent = builderMode ? 'BUILDER MODE • Tap/click to toggle tile • B: Exit • ESC: Menu' : '←/→ Move • ↑/SPACE Jump • B: Builder • I: Invert • ESC: Menu'; }
}, 1000/60);

/* ---------- Load autosave if present ---------- */
(function loadAutosave() {
  const raw = localStorage.getItem(LS_PREFIX + 'autosave');
  if (raw) {
    try { const d = JSON.parse(raw); level.importData(d); showTransient('Restored autosave'); } catch (err) { console.warn('Autosave parse failed', err); }
  }
})();

/* ---------- Periodic autosave while in builder ---------- */
setInterval(() => { if (builderMode) autosaveCurrentLevel(); }, 4000);

/* ---------- Menu startup ---------- */
document.getElementById('menu').style.display = 'block';
inMenu = true;
refreshSavedList();
scanFolderForJSON();
updateTouchControlsVisibility();

/* ---------- Bind export/import/menu controls ---------- */
document.getElementById('exportClose').addEventListener('click', () => exportDialog.style.display = 'none');
document.getElementById('menu').addEventListener('keydown', (e) => { if (inMenu && (e.code === 'Enter' || e.code === 'Space')) hideMenu(); });
document.getElementById('exportArea').style.fontFamily = 'monospace';
document.getElementById('importArea').style.fontFamily = 'monospace';

/* ---------- Exposure: allow toggling builder from keyboard while playing ---------- */
window.addEventListener('keydown', (e) => {
  if (e.code === 'KeyB' && !inMenu) { builderMode = !builderMode; showTransient(builderMode ? 'Builder ON' : 'Builder OFF'); }
});

/* ---------- Comments / Notes ----------
  - No runtime procedural/generated tiles are created anywhere.
    Only "starter" tiles created in resetToBlank() exist by default.
    All additional tiles must be placed via Builder or imported JSON.
  - Export format:
    { staticPlatforms: [{x,y,w,h,checkpoint?}, ...], builderTiles: { "tx_ty": true }, checkpointX: number }
  - Remote folder scanning is best-effort: it parses the directory HTML for ".json" links.
    If your server doesn't list the directory, add explicit <a href="file.json"> links in index.html or use Import.
  - Builder autosaves to localStorage under prefix "pf_level_autosave".
  - Saved named levels use localStorage key "pf_level_<name>".
  - Touch controls appear automatically on touch devices when not in menu.
*/

</script>
</body>
</html>